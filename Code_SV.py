import numpy as npimport matplotlib.pyplot as ppimport pycuda.driver as cudafrom pycuda.compiler import SourceModulefrom scipy.signal import butter, filtfilt# On choisit le GPU sur lequel le code va tourner (entre 0 et 3)# Et on crée le contexte dessuscuda.init()dev = cuda.Device(0)contx = dev.make_context()# Définition du domaine d'étudex_min = -2000x_max = 2000z_min = -2000z_max = 2000Tf = 1Nz = 200Nx = 200# Teste si Nz et Nx sont sous la bonne forme pour les GPUif (Nx - 2) % 32 != 0:    Nx += 32 - (Nx - 2) % 32if (Nz - 2) % 32 != 0:    Nz += 32 - (Nz - 2) % 32# Définition des pas de discrétisation spatial pour le GPUdz = np.float32((z_max - z_min) / (Nz - 1))dx = np.float32((x_max - x_min) / (Nx - 1))# Création des matrice du maillageX, Z = np.meshgrid(np.linspace(x_min, x_max, Nx), np.linspace(z_min, z_max, Nz))# Création du vecteurx = X[0, :]x = x.astype(np.float32)x_gpu = cuda.mem_alloc(x.nbytes)cuda.memcpy_htod(x_gpu, x)# Définition de la position de la sourcex_source = 0z_source = 0i_source = np.int32(int((x_source - x_min) / dx))j_source = np.int32(int((z_source - z_min) / dz))mod = SourceModule("""#include <math.h>__device__ float sinc(float x){    if (x==0)    {return(1);}    else    {return(sin(3.1415*x)/(3.1415*x));}} __device__ float Df(float xn1,float xn, float dx){    return((xn1-xn)/dx);}__device__ float Source(float t,float dt){    float alpha =40.0;    float t0 = 5.0*t;    float result=-2* alpha * (t - t0) * exp(-alpha * (t - t0) * (t-t0));    return (result);}__global__ void stress_to_velocity(float *u, float *v, float *b, float *sigma_xx,float *sigma_zz, float *sigma_xz, float dt, float dx, float dz){     int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+ (threadIdx.y + 1 + blockDim.y * blockIdx.y) * (blockDim.x *gridDim.x+2);    u[idx] += b[2*idx]*dt*Df(sigma_xx[idx],sigma_xx[idx-1],dx)+b[2*idx]*dt*Df(sigma_xz[idx],sigma_xz[idx-(blockDim.x*gridDim.x+2)],dz);    v[idx] += b[2*idx+1]*dt*Df(sigma_xz[idx],sigma_xz[idx-1],dx)+b[2*idx+1]*dt*Df(sigma_zz[idx],sigma_zz[idx-(blockDim.x*gridDim.x+2)],dz);}__global__ void velocity_to_stress(float *u, float *v, float *l, float *m, int i_source, int j_source , float *sigma_xx,float *sigma_zz, float *sigma_xz,float dt ,float dx,float dz, float t){     int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+ (threadIdx.y + 1 + blockDim.y * blockIdx.y) * (blockDim.x *gridDim.x+2);    int source = i_source+ j_source*(blockDim.x*gridDim.x+2);    sigma_xx[idx] += (l[idx]+2*m[2*idx+1])*dt*Df(u[idx+1],u[idx],dx)+l[idx]*dt*Df(v[idx+(blockDim.x*gridDim.x+2)],v[idx],dz);    sigma_zz[idx] += (l[idx]+2*m[2*idx+1])*dt*Df(v[idx+(blockDim.x*gridDim.x+2)],v[idx],dz)+l[idx]*dt*Df(u[idx+1],u[idx],dx);    sigma_xz[idx] += (m[2*idx+1])*dt*(Df(v[idx+1],v[idx],dx)+Df(u[idx+(blockDim.x*gridDim.x+2)],u[idx],dz));    if (idx == source)    {        float excitation = Source(t,dt);        sigma_xx[idx] += dt * excitation;        sigma_zz[idx] += dt * excitation;    }}__global__ void Calcul_point_miroir(float *coor_miroir, float *z_fantome, float *z_surface,float *x_fantome,float *x_surface){    int idx = (threadIdx.x+1+blockIdx.x*blockDim.x);    int i=-10;    float min_dist = (x_fantome[idx]-x_surface[10*idx-10])*(x_fantome[idx]-x_surface[10*idx-10])+    (z_fantome[idx]-z_surface[10*idx-10])*(z_fantome[idx]-z_surface[10*idx-10]);    int i_min=-10;    for (i=-10;i<10;i++)         {        if ((x_fantome[idx]-x_surface[10*idx+i])*(x_fantome[idx]-x_surface[10*idx+i])+        (z_fantome[idx]-z_surface[10*idx+i])*(z_fantome[idx]-z_surface[10*idx+i])<min_dist)            {                min_dist=(x_fantome[idx]-x_surface[10*idx+i])*(x_fantome[idx]-x_surface[10*idx+i])+                (z_fantome[idx]-z_surface[10*idx+i])*(z_fantome[idx]-z_surface[10*idx+i]);                i_min=i;            }        }    coor_miroir[2*idx]=2*x_surface[10*idx+i_min]-x_fantome[idx];    coor_miroir[2*idx+1]=2*z_surface[10*idx+i_min]-z_fantome[idx];}__global__ void Mise_a_zero_miroir_velocity (float *p, int *coor_fantome_z){    if(threadIdx.y+blockDim.y *blockIdx.y+1>coor_fantome_z[threadIdx.x+blockDim.x *blockIdx.x+1]-1)    {        p[threadIdx.x+1+blockDim.x *blockIdx.x+(threadIdx.y+1+blockDim.y *blockIdx.y)*(blockDim.x *gridDim.x+2)]=0;    }}__global__ void Iteration_miroir_velocity (float *coor_miroir, float *p,float *p_cpy, int *coor_fantome_z,float dx,float dz,int Nz){    int idx=(threadIdx.x+1) +(blockIdx.x*blockDim.x);    float pvalue=0;    int i=0;    int j=0;    float Bx=1/(2*dx);    float Bz=1/(2*dz);    float rx=2*Bx*dx;    float ry=2*Bz*dz;    for(i=1;i<blockDim.x *gridDim.x+1;i++)    {        for (j=1;j<Nz;j++)        {            pvalue+=rx*ry*p_cpy[i+j*(blockDim.x *gridDim.x+2)]*sinc(2*Bx*coor_miroir[2*idx]-rx*i)*sinc(2*Bz*coor_miroir[2*idx+1]-ry*j);        }    }    p[idx+coor_fantome_z[idx]*(blockDim.x *gridDim.x+2)]=-pvalue;  }""")# Definition des points de la courbeNx_courbe = 10 * (Nx - 1) + 1dx_courbe = np.float32((x_max - x_min) / (Nx_courbe - 1))x_surface = np.linspace(x_min, x_max, Nx_courbe)x_surface = x_surface.astype(np.float32)x_surface_gpu = cuda.mem_alloc(x_surface.nbytes)cuda.memcpy_htod(x_surface_gpu, x_surface)z_surface = 1000 * np.exp(-np.square(x_surface) / (1000) ** 2)def filtre_surface(data, cutoff, fs, order):    normal_cutoff = 2 * cutoff / fs    b, a = butter(order, normal_cutoff, btype=('low'), analog=False)    y = filtfilt(b, a, data)    return (y)# Filtrage de la courbez_surface = filtre_surface(z_surface, 1 / (dx), 1 / dx_courbe, 4)z_surface = z_surface.astype(np.float32)z_surface_gpu = cuda.mem_alloc(z_surface.nbytes)cuda.memcpy_htod(z_surface_gpu, z_surface)# Définition  des points fantome et miroirz_fantome = []for i in range(Nx):    z_fantome.append((int((z_surface[10 * i] + z_min) / dz) + 1) * dz - z_min)z_fantome = np.array(z_fantome)z_fantome = z_fantome.astype(np.float32)z_fantome_gpu = cuda.mem_alloc(z_fantome.nbytes)cuda.memcpy_htod(z_fantome_gpu, z_fantome)Coor_miroir = np.zeros((Nx, 2))Coor_miroir = Coor_miroir.astype(np.float32)Coor_miroir_gpu = cuda.mem_alloc(Coor_miroir.nbytes)cuda.memcpy_htod(Coor_miroir_gpu, Coor_miroir)Coor_point_fantome = (z_fantome - z_min) / dzCoor_point_fantome = Coor_point_fantome.astype(np.int32)Coor_point_fantome_gpu = cuda.mem_alloc(Coor_point_fantome.nbytes)cuda.memcpy_htod(Coor_point_fantome_gpu, Coor_point_fantome)# Définition de l'état initialU = np.zeros((Nz, Nx))  # Vitesse selon xU = U.astype(np.float32)U_gpu = cuda.mem_alloc(U.nbytes)cuda.memcpy_htod(U_gpu, U)U_gpu_cpy = cuda.mem_alloc(U.nbytes)cuda.memcpy_htod(U_gpu_cpy, U)V = np.zeros((Nz, Nx))  # Vitesse selon xV = V.astype(np.float32)V_gpu = cuda.mem_alloc(V.nbytes)cuda.memcpy_htod(V_gpu, V)V_gpu_cpy = cuda.mem_alloc(V.nbytes)cuda.memcpy_htod(V_gpu_cpy, V)Sigma_xx = np.zeros((Nz, Nx))  # Stress selon xxSigma_xx = Sigma_xx.astype(np.float32)Sigma_xx_gpu = cuda.mem_alloc(Sigma_xx.nbytes)cuda.memcpy_htod(Sigma_xx_gpu, Sigma_xx)Sigma_xx_gpu_cpy = cuda.mem_alloc(Sigma_xx.nbytes)cuda.memcpy_htod(Sigma_xx_gpu_cpy, Sigma_xx)Sigma_xz = np.zeros((Nz, Nx))  # Stress selon xzSigma_xz = Sigma_xz.astype(np.float32)Sigma_xz_gpu = cuda.mem_alloc(Sigma_xz.nbytes)cuda.memcpy_htod(Sigma_xz_gpu, Sigma_xz)Sigma_xz_gpu_cpy = cuda.mem_alloc(Sigma_xz.nbytes)cuda.memcpy_htod(Sigma_xz_gpu_cpy, Sigma_xz)Sigma_zz = np.zeros((Nz, Nx))  # Stress selon zzSigma_zz = Sigma_zz.astype(np.float32)Sigma_zz_gpu = cuda.mem_alloc(Sigma_zz.nbytes)cuda.memcpy_htod(Sigma_zz_gpu, Sigma_zz)Sigma_zz_gpu_cpy = cuda.mem_alloc(Sigma_zz.nbytes)cuda.memcpy_htod(Sigma_zz_gpu_cpy, Sigma_zz)# Définition des propriétés du solVp = 3500  # Vitesse des ondes PVs = 1500  # Vitesse des ondes Srho = 10000  # DensitéB = np.ones((2 * Nz, Nx)) / rho  # Inverse de la densité (i,i+1/2,j,j+1/2)B = B.astype(np.float32)B_gpu = cuda.mem_alloc(B.nbytes)cuda.memcpy_htod(B_gpu, B)L = (rho * Vp ** 2 - 2 * rho * Vs ** 2) * np.ones((Nz, Nx))  # Coefficient Lambda (i+1/2,j)L = L.astype(np.float32)L_gpu = cuda.mem_alloc(L.nbytes)cuda.memcpy_htod(L_gpu, L)M = rho * Vs ** 2 * np.ones((2 * Nz, Nx))  # Coefficient Mu (i,i+1/2,j,j+1/2)M = M.astype(np.float32)M_gpu = cuda.mem_alloc(M.nbytes)cuda.memcpy_htod(M_gpu, M)# Définitions du pas de tempsdt = np.float32(0.5 * dx / (np.sqrt(2) * Vp))Nt = int(Tf / dt) + 1nt = 0t = np.float32(0)# Importation des fonctions cudastress_to_velocity = mod.get_function("stress_to_velocity")velocity_to_stress = mod.get_function("velocity_to_stress")Calcul_point_miroir = mod.get_function("Calcul_point_miroir")Mise_a_zero_miroir_velocity = mod.get_function("Mise_a_zero_miroir_velocity")Iteration_miroir = mod.get_function("Iteration_miroir_velocity")longueur_grille_x = (Nx - 2) // 32longueur_grille_z = (Nz - 2) // 32hauteur_matrice_z = np.int32(Nz)# Calcul des points miroirsCalcul_point_miroir(Coor_miroir_gpu, z_fantome_gpu, z_surface_gpu, x_gpu, x_surface_gpu, block=(32, 1, 1),                    grid=(longueur_grille_x, 1))pp.figure(figsize=(15, 15))pp.plot(x_surface, z_surface)pp.plot(x, z_fantome)cuda.memcpy_dtoh(Coor_miroir, Coor_miroir_gpu)pp.plot(Coor_miroir[:, 0], Coor_miroir[:, 1])pp.showwhile nt < Nt:    # Itération en temps    nt += 1    t += dt    # Calcul des contraintes sur toute la matrice    velocity_to_stress(U_gpu, V_gpu, L_gpu, M_gpu, i_source, j_source, Sigma_xx_gpu, Sigma_zz_gpu, Sigma_xz_gpu, dt, dx,                       dz, t, block=(32, 32, 1), grid=(longueur_grille_x, longueur_grille_z))    #    Mise_a_zero_miroir_velocity(Sigma_xx_gpu, Coor_point_fantome_gpu, block=(32, 32, 1),                                grid=(longueur_grille_x, longueur_grille_z))    Mise_a_zero_miroir_velocity(Sigma_xz_gpu, Coor_point_fantome_gpu, block=(32, 32, 1),                                grid=(longueur_grille_x, longueur_grille_z))    Mise_a_zero_miroir_velocity(Sigma_zz_gpu, Coor_point_fantome_gpu, block=(32, 32, 1),                                grid=(longueur_grille_x, longueur_grille_z))    for i in [1, 10]:        Iteration_miroir(Coor_miroir_gpu, Sigma_xx_gpu, Sigma_xx_gpu_cpy, Coor_point_fantome_gpu, dx, dz,                         hauteur_matrice_z, block=(32, 1, 1), grid=(longueur_grille_x, 1))        Iteration_miroir(Coor_miroir_gpu, Sigma_xz_gpu, Sigma_xz_gpu_cpy, Coor_point_fantome_gpu, dx, dz,                         hauteur_matrice_z, block=(32, 1, 1), grid=(longueur_grille_x, 1))        Iteration_miroir(Coor_miroir_gpu, Sigma_zz_gpu, Sigma_zz_gpu_cpy, Coor_point_fantome_gpu, dx, dz,                         hauteur_matrice_z, block=(32, 1, 1), grid=(longueur_grille_x, 1))    cuda.memcpy_dtod(Sigma_xx_gpu_cpy, Sigma_xx_gpu, Sigma_xx.nbytes)    cuda.memcpy_dtod(Sigma_xz_gpu_cpy, Sigma_xz_gpu, Sigma_xz.nbytes)    cuda.memcpy_dtod(Sigma_zz_gpu_cpy, Sigma_zz_gpu, Sigma_zz.nbytes)    stress_to_velocity(U_gpu, V_gpu, B_gpu, Sigma_xx_gpu, Sigma_zz_gpu, Sigma_xz_gpu, dt, dx, dz, block=(32, 32, 1),                       grid=(longueur_grille_x, longueur_grille_z))    Mise_a_zero_miroir_velocity(U_gpu, Coor_point_fantome_gpu, block=(32, 32, 1),                                grid=(longueur_grille_x, longueur_grille_z))    Mise_a_zero_miroir_velocity(V_gpu, Coor_point_fantome_gpu, block=(32, 32, 1),                                grid=(longueur_grille_x, longueur_grille_z))    for i in [1, 10]:        Iteration_miroir(Coor_miroir_gpu, U_gpu, U_gpu_cpy, Coor_point_fantome_gpu, dx, dz, hauteur_matrice_z,                         block=(32, 1, 1), grid=(longueur_grille_x, 1))        Iteration_miroir(Coor_miroir_gpu, V_gpu, V_gpu_cpy, Coor_point_fantome_gpu, dx, dz, hauteur_matrice_z,                         block=(32, 1, 1), grid=(longueur_grille_x, 1))    cuda.memcpy_dtod(U_gpu_cpy, U_gpu, U.nbytes)    cuda.memcpy_dtod(V_gpu_cpy, V_gpu, V.nbytes)    # Affichage en python    if nt % 50 == 0:        # On importe les résultats Cuda en python        cuda.memcpy_dtoh(U, U_gpu)        cuda.memcpy_dtoh(V, V_gpu)        cuda.memcpy_dtoh(Sigma_xx, Sigma_xx_gpu)        cuda.memcpy_dtoh(Sigma_xz, Sigma_xz_gpu)        cuda.memcpy_dtoh(Sigma_zz, Sigma_zz_gpu)        fig, axs = pp.subplots(2, 2, constrained_layout=True, figsize=(10, 6))        gridspec = axs[0, 0].get_subplotspec().get_gridspec()        ax1 = axs[0, 0]        # Affichage U        Umin = np.min(U)        Umax = np.max(U)        mylevelsU = np.linspace(Umin, Umax, 30)        ax1.contourf(X, Z, U, levels=mylevelsU, cmap="coolwarm")        ax1.set_title("U")        ax1.set_xlabel("x")        ax1.set_ylabel("z")        # Affichage V        ax2 = axs[0, 1]        Vmin = np.min(V)        Vmax = np.max(V)        mylevelsV = np.linspace(Vmin, Vmax, 30)        ax2.contourf(X, Z, V, levels=mylevelsV, cmap="coolwarm")        ax2.set_title("V")        ax2.set_xlabel("x")        ax2.set_ylabel("z")        #   Affichage Sigma_xx        ax3 = axs[1, 0]        Sigma_xx_min = np.min(Sigma_xx)        Sigma_xx_max = np.max(Sigma_xx)        mylevels_Sigma_xx = np.linspace(Sigma_xx_min, Sigma_xx_max, 30)        ax3.contourf(X, Z, Sigma_xx, levels=mylevels_Sigma_xx, cmap="coolwarm")        ax3.set_title("Sigma_xx")        ax3.set_xlabel("x")        ax3.set_ylabel("z")        # Affichage Sigma_zz        ax4 = axs[1, 1]        Sigma_zz_min = np.min(Sigma_zz)        Sigma_zz_max = np.max(Sigma_zz)        mylevels_Sigma_zz = np.linspace(Sigma_zz_min, Sigma_zz_max, 30)        ax4.contourf(X, Z, Sigma_zz, levels=mylevels_Sigma_zz, cmap="coolwarm")        ax4.set_title("Sigma_zz")        ax4.set_xlabel("x")        ax4.set_ylabel("z")        pp.show()# Suppression du contextecontx.pop()print(0)