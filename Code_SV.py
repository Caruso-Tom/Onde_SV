import numpy as npimport matplotlib.pyplot as ppimport pycuda.driver as cudafrom pycuda.compiler import SourceModulefrom scipy.signal import butter, filtfiltdef numpy_to_gpu(matrix):    matrix = matrix.astype(np.float32)    matrix_gpu = cuda.mem_alloc(matrix.nbytes)    cuda.memcpy_htod(matrix_gpu, matrix)    return [matrix, matrix_gpu]def view_velocity_stress(x_matrix, z_matrix, u_matrix, v_matrix, sigma_xx_matrix, sigma_zz_matrix, sigma_xz_matrix,                         surface_point_x=[], surface_point_z=[], trace_type='coolwarm'):    fig, axs = pp.subplots(3, 2, constrained_layout=True, figsize=(10, 10))    gridspec = axs[0, 0].get_subplotspec().get_gridspec()    # Ploat U    ax1 = axs[0, 0]    u_min = np.min(u_matrix)    u_max = np.max(u_matrix)    u_abs = max(u_max, -u_min)    if u_abs == 0:        u_abs = 0.1        print("Warning : There is no movement")    levels_u = np.linspace(-u_abs, u_abs, 20)    ax1.contourf(x_matrix, z_matrix, u_matrix, levels=levels_u, cmap=trace_type)    ax1.set_title("Velocity on x")    ax1.set_xlabel("x")    ax1.set_ylabel("z")    # Ploat V    ax2 = axs[0, 1]    v_min = np.min(v_matrix)    v_max = np.max(v_matrix)    v_abs = max(v_max, -v_min)    if v_abs == 0:        v_abs = 0.11        print("Warning : There is no movement")    levels_v = np.linspace(-v_abs, v_abs, 20)    ax2.contourf(x_matrix, z_matrix, v_matrix, levels=levels_v, cmap=trace_type)    ax2.set_title("Velocity on z")    ax2.set_xlabel("x")    ax2.set_ylabel("z")    # Ploat Sigma_xx    ax3 = axs[1, 0]    sigma_xx_min = np.min(sigma_xx_matrix)    sigma_xx_max = np.max(sigma_xx_matrix)    sigma_xx_abs = max(sigma_xx_max, -sigma_xx_min)    if sigma_xx_abs == 0:        sigma_xx_abs = 0.11        print("Warning : There is no stress")    levels_sigma_xx = np.linspace(-sigma_xx_abs, sigma_xx_abs, 20)    ax3.contourf(x_matrix, z_matrix, sigma_xx_matrix, levels=levels_sigma_xx, cmap=trace_type)    ax3.set_title("Sigma_xx")    ax3.set_xlabel("x")    ax3.set_ylabel("z")    # Ploat Sigma_zz    ax4 = axs[1, 1]    sigma_zz_min = np.min(sigma_zz_matrix)    sigma_zz_max = np.max(sigma_zz_matrix)    sigma_zz_abs = max(sigma_zz_max, -sigma_zz_min)    if sigma_zz_abs == 0:        sigma_zz_abs = 0.1        print("Warning : There is no stress")    levels_sigma_zz = np.linspace(-sigma_zz_abs, sigma_zz_abs, 20)    ax4.contourf(x_matrix, z_matrix, sigma_zz_matrix, levels=levels_sigma_zz, cmap=trace_type)    ax4.set_title("Sigma_zz")    ax4.set_xlabel("x")    ax4.set_ylabel("z")    # Ploat Sigma_xz    ax5 = axs[2, 0]    sigma_xz_min = np.min(sigma_xz_matrix)    sigma_xz_max = np.max(sigma_xz_matrix)    sigma_xz_abs = max(sigma_xz_max, -sigma_xz_min)    if sigma_xz_abs == 0:        sigma_xz_abs = 0.1        print("Warning : There is no stress")    levels_sigma_xz = np.linspace(-sigma_xz_abs, sigma_xz_abs, 20)    ax5.contourf(x_matrix, z_matrix, sigma_xz_matrix, levels=levels_sigma_xz, cmap=trace_type)    ax5.set_title("Sigma_xz")    ax5.set_xlabel("x")    ax5.set_ylabel("z")    # Ploating surfaces on each figure    if surface_point_z != [] and surface_point_x != []:        ax1.plot(surface_point_x, surface_point_z, 'k')        ax2.plot(surface_point_x, surface_point_z, 'k')        ax3.plot(surface_point_x, surface_point_z, 'k')        ax4.plot(surface_point_x, surface_point_z, 'k')        ax5.plot(surface_point_x, surface_point_z, 'k')    pp.show()def compute_mirror_point(mirror_point_coordinate_gpu, ghost_point_z_gpu, surface_point_z_gpu,                         ghost_point_x_gpu, surface_point_x_gpu, longueur_grille_x):    mod_def_mirror_point = SourceModule("""    __device__ float distance(float x1, float x2, float z1, float z2)    {    float dist =(z1-z2)*(z1-z2)+(x1-x2)*(x1-x2);    return(dist);    }    __global__ void mirror_point(float *coordinate_mirror_point, float *ghost_point_z, float *surface_point_z,                                 float *ghost_point_x, float *surface_point_x)    {        int idx = (threadIdx.x+1+blockIdx.x*blockDim.x);        int i=-10;        float min_dist = distance(ghost_point_x[idx], surface_point_x[10*idx-10], ghost_point_z[idx],                                   surface_point_z[10*idx-10]);        int i_min=-10;        for (i=-10;i<10;i++)         {            if (distance(ghost_point_x[idx], surface_point_x[10*idx+i], ghost_point_z[idx], surface_point_z[10*idx+i])                <min_dist)            {                min_dist=distance(ghost_point_x[idx], surface_point_x[10*idx+i], ghost_point_z[idx],                                   surface_point_z[10*idx+i]);                i_min=i;            }        }        coordinate_mirror_point[2*idx]=2*surface_point_x[10*idx+i_min]-ghost_point_x[idx];        coordinate_mirror_point[2*idx+1]=2*surface_point_z[10*idx+i_min]-ghost_point_z[idx];    }""")    mirror_point = mod_def_mirror_point.get_function("mirror_point")    mirror_point(mirror_point_coordinate_gpu, ghost_point_z_gpu, surface_point_z_gpu, ghost_point_x_gpu,                 surface_point_x_gpu, block=(32, 1, 1),                 grid=(longueur_grille_x, 1))def interpolation_on_mirror_point(matrix_gpu, matrix_ghost_points_gpu, longueur_grille_x, longueur_grille_z,                                  ghost_point_coordinate_matrix_gpu, interpolation_factor_gpu,                                  mirror_point_coordinate_gpu, n_z, interpolation_size,                                  dx, dz, reset_above_surface, compute_mirror_iteration, assign_value_ghost_point):    reset_above_surface(matrix_gpu, ghost_point_coordinate_matrix_gpu, block=(32, 32, 1),                        grid=(longueur_grille_x, longueur_grille_z))    for i in [1, 40]:        compute_mirror_iteration(matrix_gpu, matrix_ghost_points_gpu, mirror_point_coordinate_gpu,                                 interpolation_factor_gpu, n_z, interpolation_size, dx, dz,                                  block=(32, 1, 1), grid=(longueur_grille_x, 1))        assign_value_ghost_point(matrix_gpu, matrix_ghost_points_gpu, ghost_point_coordinate_matrix_gpu,                                 block=(32, 1, 1), grid=(longueur_grille_x, 1))def initial_state(n_x, n_z):    matrix = np.zeros((n_z, n_x))    matrix = matrix.astype(np.float32)    matrix_gpu = cuda.mem_alloc(matrix.nbytes)    cuda.memcpy_htod(matrix_gpu, matrix)    return [matrix, matrix_gpu]def treating_soil_matrix(b_matrix, l_matrix, m_matrix, longueur_grille_x, longueur_grille_z):    [b_matrix, b_matrix_gpu] = numpy_to_gpu(b_matrix)    b_matrix_moved_ij_gpu = cuda.mem_alloc(b_matrix.nbytes)    cuda.memcpy_dtod(b_matrix_moved_ij_gpu, b_matrix_gpu, b_matrix.nbytes)    [l_matrix, l_matrix_gpu] = numpy_to_gpu(l_matrix)    l_matrix_moved_i_gpu = cuda.mem_alloc(l_matrix.nbytes)    cuda.memcpy_dtod(l_matrix_moved_i_gpu, l_matrix_gpu, l_matrix.nbytes)    [m_matrix, m_matrix_gpu] = numpy_to_gpu(m_matrix)    m_matrix_moved_dec_i_gpu = cuda.mem_alloc(m_matrix.nbytes)    cuda.memcpy_dtod(m_matrix_moved_dec_i_gpu, m_matrix_gpu, m_matrix.nbytes)    m_matrix_moved_dec_j_gpu = cuda.mem_alloc(m_matrix.nbytes)    cuda.memcpy_dtod(m_matrix_moved_dec_j_gpu, m_matrix_gpu, m_matrix.nbytes)    mod_soil = SourceModule("""    #define NX (blockDim.x*gridDim.x+2)    __global__ void moving_b(float *b_matrix, float *b_matrix_moved_ij)    {        int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+(threadIdx.y + 1 + blockDim.y * blockIdx.y) * NX;        b_matrix_moved_ij[idx]=4/(1/(b_matrix[idx])+1/(b_matrix[idx+1])+1/(b_matrix[idx+NX])+1/(b_matrix[idx+NX+1]));    }    __global__ void moving_l(float *l_matrix, float *l_matrix_moved_i)    {        int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+(threadIdx.y + 1 + blockDim.y * blockIdx.y) * NX;        l_matrix_moved_i[idx]=2/(1/(l_matrix[idx])+1/(l_matrix[idx+1]));    }    __global__ void moving_m(float *m_matrix, float *m_matrix_moved_dec_i, float *m_matrix_moved_dec_j)    {        int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+(threadIdx.y + 1 + blockDim.y * blockIdx.y) * NX;        m_matrix_moved_dec_i[idx]=2/(1/(m_matrix[idx])+1/(m_matrix[idx+1]));        m_matrix_moved_dec_j[idx]=2/(1/(m_matrix[idx])+1/(m_matrix[idx+NX]));    }    """)    moving_b = mod_soil.get_function("moving_b")    moving_l = mod_soil.get_function("moving_l")    moving_m = mod_soil.get_function("moving_m")    moving_b(b_matrix_gpu, b_matrix_moved_ij_gpu, block=(32, 32, 1), grid=(longueur_grille_x, longueur_grille_z))    moving_l(l_matrix_gpu, l_matrix_moved_i_gpu, block=(32, 32, 1), grid=(longueur_grille_x, longueur_grille_z))    moving_m(m_matrix_gpu, m_matrix_moved_dec_i_gpu, m_matrix_moved_dec_j_gpu, block=(32, 32, 1),             grid=(longueur_grille_x, longueur_grille_z))    #     cuda.memcpy_dtoh(B, B_gpu)    #     print(B)    #     cuda.memcpy_dtoh(B, b_matrix_moved_ij_gpu)    #     print(B)    #     cuda.memcpy_dtoh(L, L_dec_i_gpu)    #     print(L)    #     cuda.memcpy_dtoh(M, M_dec_i_gpu)    #     print(M)    #     cuda.memcpy_dtoh(M, M_dec_j_gpu)    #     print(M)    return [b_matrix_gpu, b_matrix_moved_ij_gpu, l_matrix_moved_i_gpu, m_matrix_moved_dec_i_gpu,            m_matrix_moved_dec_j_gpu]def function_cuda():    mod = SourceModule("""    #define NX (blockDim.x*gridDim.x+2)    __device__ float df(float xn1,float xn, float dx)    {        return((xn1-xn)/dx);    }    __global__ void stress_to_velocity(float *u, float *v, float *b, float *b_moved_ij, float *sigma_xx,                                        float *sigma_zz, float *sigma_xz, float dt, float dx, float dz)    {         int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+         (threadIdx.y + 1 + blockDim.y * blockIdx.y) * NX;        u[idx] += b[idx]*dt*(df(sigma_xx[idx],sigma_xx[idx-1],dx)+        df(sigma_xz[idx],sigma_xz[idx-NX],dz));        v[idx] += b_moved_ij[idx]*dt*(df(sigma_xz[idx+1],sigma_xz[idx],dx)+        df(sigma_zz[idx + NX],sigma_zz[idx],dz));    }    __global__ void velocity_to_stress(float *u, float *v, float *l_moved_i, float *m_moved_i, float *m_moved_j,                                        int source_position, float *sigma_xx, float *sigma_zz, float *sigma_xz,float dt,                                        float dx, float dz, float source_t)    {         int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x)+ (threadIdx.y + 1 + blockDim.y * blockIdx.y) * NX;        sigma_xx[idx] += (l_moved_i[idx]+2*m_moved_i[idx])*dt*df(u[idx+1],u[idx],dx)+        l_moved_i[idx]*dt*df(v[idx],v[idx-NX],dz);        sigma_zz[idx] += (l_moved_i[idx]+2*m_moved_i[idx])*dt*df(v[idx],v[idx-NX],dz)+        l_moved_i[idx]*dt*df(u[idx+1],u[idx],dx);        sigma_xz[idx] += (m_moved_j[idx])*dt*(df(v[idx],v[idx-1],dx)+        df(u[idx+NX],u[idx],dz));        if (idx == source_position)        {            sigma_xx[idx] += source_t;            sigma_zz[idx] += source_t;        }    }    __device__ float sinc(float x)    {        if (x==0)        {return(1);}        else        {return(sin(M_PI*x)/(M_PI*x));}    }    __global__ void compute_interpolation_factor(float *interpolation_factor, float *mirror_coordinate                                                    ,float dx, float dz, int size_iter, int n_z)    {         int idx = (threadIdx.x+1) +(blockIdx.x*blockDim.x);        int i=0;        int j=0;        int m= 0;        int n= 0;        float Bx=1/(2*dx);        float Bz=1/(2*dz);        float rx=2*Bx*dx;        float ry=2*Bz*dz;        for (i=0;i<size_iter;i++)        {            m=mirror_coordinate[2*idx]/dx+i-size_iter/2;            if ((m>0)&&(m<NX))            {                            for (j=0 ;j<size_iter ;j++)                 {                    n=mirror_coordinate[2*idx+1]/dz+j-size_iter/2;                    if ((n>0)&&(n<n_z))                    {                        interpolation_factor[i+j*size_iter+idx*size_iter*size_iter] = rx*ry*sinc(2*Bx                        * mirror_coordinate[2*idx]-rx*m) * sinc(2*Bz*mirror_coordinate[2*idx+1]-ry*n);                    }                }            }        }    }     __global__ void reset_above_surface(float *matrix, int *ghost_point_matrice_coordinate_z)    {        if(threadIdx.y+blockDim.y *blockIdx.y+1>ghost_point_matrice_coordinate_z[threadIdx.x+blockDim.x *blockIdx.x+1]-1)        {            matrix[threadIdx.x+1+blockDim.x *blockIdx.x+(threadIdx.y+1+blockDim.y *blockIdx.y)*NX]=0;        }    }    __global__ void compute_mirror_iteration (float *matrix, double *matrix_ghost_point_interpolated, float *mirror_coordinate,                                            float *interpolation_factor, int n_z, int size_iter, float dx, float dz)    {        int idx=(threadIdx.x+1) +(blockIdx.x*blockDim.x);        double value=0;        int i=0;        int j=0;        int m=0;        int n=0;        for (i=0;i<size_iter;i++)        {            m=mirror_coordinate[2*idx]/dx+i-size_iter/2;            if ((m>0)&&(m<NX))            {                            for (j=0 ;j<size_iter ;j++)                 {                    n=mirror_coordinate[2*idx+1]/dz+j-size_iter/2;                    if ((n>0)&&(n<n_z))                    {                        value+=matrix[m+n*NX]*interpolation_factor[i+j*size_iter+idx*size_iter*size_iter];                    }                }            }        }        matrix_ghost_point_interpolated[idx]= value;     }    __global__ void assign_value_ghost_point(float *matrix, double *matrix_ghost_point_interpolated,                                             int *ghost_point_matrix_coordinate_z)    {        int idx=(threadIdx.x+1) +(blockIdx.x*blockDim.x);        matrix[idx+ghost_point_matrix_coordinate_z[idx]*NX] = -matrix_ghost_point_interpolated[idx];     }    """)    compute_interpolation_factor = mod.get_function("compute_interpolation_factor")    stress_to_velocity = mod.get_function("stress_to_velocity")    velocity_to_stress = mod.get_function("velocity_to_stress")    reset_above_surface = mod.get_function("reset_above_surface")    compute_mirror_iteration = mod.get_function("compute_mirror_iteration")    assign_value_ghost_point = mod.get_function("assign_value_ghost_point")    return (        [compute_interpolation_factor, stress_to_velocity, velocity_to_stress, reset_above_surface,         compute_mirror_iteration, assign_value_ghost_point])def testing_entry(dx, dz, dt, b_matrix, l_matrix, m_matrix, ):    def test_size_soil(b_matrix, l_matrix, m_matrix):        n_z = np.size(b_matrix, 0)        n_x = np.size(b_matrix, 1)        if n_x != np.size(l_matrix, 1) or n_z != np.size(l_matrix, 0):            raise TypeError("B and L are not the same size.")        elif n_x != np.size(m_matrix, 1) or n_z != np.size(m_matrix, 0):            raise TypeError("B and M are not the same size.")        elif (n_x - 2) % 32 != 0 or (n_z - 2) % 32 != 0:            raise TypeError("The size of the matrix must be on this form 32*n+2. And they are not.")    def test_discretization(dx, dz, dt, v_p):        max_d = max(dx, dz)        min_d = min(dx, dz)        if dt / max_d > 1 / (np.sqrt(2) * v_p):            raise TypeError("dt/dx is too big. It must be less than :" + str(1 / (np.sqrt(2) * v_p)))        elif dt / min_d < 0.01 / (np.sqrt(2) * v_p):            raise TypeError("dt/dx is too small. It must exceed :" + str(0.01 / (np.sqrt(2) * v_p)))    test_size_soil(b_matrix, l_matrix, m_matrix)    rho = 1 / np.max(b_matrix)    v_p = np.sqrt(np.max(l_matrix + 2 * m_matrix) / rho)    test_discretization(dx, dz, dt, v_p)def treating_entry(dx, dz, source_coordinate, b_matrix, data_x, data_z):    def treating_source_position(source_coordinate, dx, dz, n_x, n_z, ghost_point_coordinate):        i_source = int((source_coordinate[0] / dx) + 0.5)        j_source = int((source_coordinate[1]) / dz + 0.5)        source_coordinate_gpu = np.int32(i_source + n_x * j_source)        if (i_source <= n_x) and (i_source >= 0) and (j_source <= n_z) and (j_source >= 0):            if j_source == n_x - 1:                source_coordinate_gpu -= 1                i_source = -1                print("Warning: Source on the border of the grid")            elif j_source == 1:                source_coordinate_gpu += 1                i_source = -1                print("Warning: Source on the border of the grid")            elif ghost_point_coordinate[i_source] < j_source:                raise TypeError("Source is above the surface")            elif j_source == 0:                source_coordinate_gpu += n_x                print("Warning: Source on the border of the grid")            elif j_source == n_z - 1:                source_coordinate_gpu -= n_x                print("Warning: Source on the border of the grid")            return source_coordinate_gpu        else:            raise TypeError("Source is not in the domain")    def create_surface(x_max, n_x, data_x, data_z, x, dz, aff_plot=False):        def surface_filter(data, cutoff, fs, order):            normal_cutoff = 2 * cutoff / fs            b, a = butter(order, normal_cutoff, btype='low', analog=False)            y = filtfilt(b, a, data)            return y        def creating_ghost_point(surface_point_z, dz, n_x):            ghost_point_z = []            for i in range(n_x):                ghost_point_z.append((int((surface_point_z[10 * i]) / dz) + 1) * dz)            ghost_point_z = np.array(ghost_point_z)            [ghost_point_z, ghost_point_z_gpu] = numpy_to_gpu(ghost_point_z)            ghost_point_matrix_coordinate_z = ghost_point_z / dz            ghost_point_matrix_coordinate_z = ghost_point_matrix_coordinate_z.astype(np.int32)            ghost_point_matrix_coordinate_z_gpu = cuda.mem_alloc(ghost_point_matrix_coordinate_z.nbytes)            cuda.memcpy_htod(ghost_point_matrix_coordinate_z_gpu, ghost_point_matrix_coordinate_z)            return [ghost_point_z, ghost_point_z_gpu, ghost_point_matrix_coordinate_z,                    ghost_point_matrix_coordinate_z_gpu]        def create_mirror_point(n_x, ghost_point_z_gpu, surface_point_z_gpu, surface_point_x_gpu, ghost_point_x_gpu):            mirror_point_coordinate = np.zeros((n_x, 2))            [mirror_point_coordinate, mirror_point_coordinate_gpu] = numpy_to_gpu(mirror_point_coordinate)            compute_mirror_point(mirror_point_coordinate_gpu, ghost_point_z_gpu, surface_point_z_gpu,                                 ghost_point_x_gpu, surface_point_x_gpu, (n_x - 2) // 32)            return [mirror_point_coordinate, mirror_point_coordinate_gpu]        def treating_data_surface(x_max, n_x, data_x, data_z):            n_x_surface = 10 * (n_x - 1) + 1            dx_surface = np.float32((x_max) / (n_x_surface - 1))            surface_point_x = np.linspace(0, x_max, n_x_surface)            [surface_point_x, surface_point_x_gpu] = numpy_to_gpu(surface_point_x)            x_data_min = np.min(data_x)            x_data_max = np.max(data_x)            if (0 < x_data_min) or (x_max < x_data_max):                raise TypeError("Data doesn't cover all the study domain.")            surface_point_z = np.interp(surface_point_x, data_x, data_z)            surface_point_z = surface_filter(surface_point_z, 1 / dx, 1 / dx_surface, 4)            [surface_point_z, surface_point_z_gpu] = numpy_to_gpu(surface_point_z)            return [surface_point_x, surface_point_x_gpu, surface_point_z, surface_point_z_gpu]        [x, x_gpu] = numpy_to_gpu(x)        [surface_point_x, surface_point_x_gpu, surface_point_z, surface_point_z_gpu] = treating_data_surface(x_max, n_x,                                                                                                             data_x,                                                                                                             data_z)        [ghost_point_z, ghost_point_z_gpu, ghost_point_matrix_coordinate_z,         ghost_point_matrix_coordinate_z_gpu] = creating_ghost_point(surface_point_z, dz, n_x)        [mirror_point_coordinate, mirror_point_coordinate_gpu] = create_mirror_point(n_x, ghost_point_z_gpu,                                                                                     surface_point_z_gpu,                                                                                     surface_point_x_gpu, x_gpu)        if aff_plot:            cuda.memcpy_dtoh(mirror_point_coordinate, mirror_point_coordinate_gpu)            pp.figure(figsize=(15, 15))            pp.plot(surface_point_x, surface_point_z)            pp.plot(x, ghost_point_z)            pp.plot(mirror_point_coordinate[1:-1, 0], mirror_point_coordinate[1:-1, 1])            pp.show        return [ghost_point_matrix_coordinate_z, ghost_point_matrix_coordinate_z_gpu, mirror_point_coordinate_gpu,                surface_point_x, surface_point_z]    n_z = np.size(b_matrix, 0)    n_x = np.size(b_matrix, 1)    # Creating dataset    X, Z = np.meshgrid(np.linspace(0, n_x * dx, n_x), np.linspace(0, n_z * dz, n_z))    # Mise en forme des données de la surface    [ghost_point_matrix_coordinate_z, ghost_point_matrix_coordinate_z_gpu, mirror_point_coordinate_gpu,     surface_point_x, surface_point_z] = create_surface(n_x * dx, n_x, data_x, data_z, X[0, :], dz)    source_position_gpu = treating_source_position(source_coordinate, dx, dz, n_x, n_z, ghost_point_matrix_coordinate_z)    return [n_x, n_z, X, Z, source_position_gpu, ghost_point_matrix_coordinate_z_gpu, mirror_point_coordinate_gpu]def propagation_with_mirror(b_matrix, l_matrix, m_matrix, dx, dz, dt, source_coordinate, vector_source,                            data_x, data_z, interpolation_size, gpu_used):    cuda.init()    dev = cuda.Device(gpu_used)    context = dev.make_context()    # Testing the entry    testing_entry(dx, dz, dt, b_matrix, l_matrix, m_matrix)    # Treating the entry    [n_x, n_z, X, Z, source_position_gpu, ghost_point_matrix_coordinate_z_gpu,     mirror_point_coordinate_gpu] = treating_entry(dx, dz, source_coordinate, b_matrix, data_x, data_z)    n_t = len(vector_source)    # Création des maillages décalés pour les caractéristiques de la surface    grid_size_x = (n_x - 2) // 32    grid_size_z = (n_z - 2) // 32    [b_matrix_gpu, b_matrix_moved_ij_gpu, l_matrix_moved_i_gpu, m_matrix_moved_i_gpu, m_matrix_moved_j_gpu] = \        treating_soil_matrix(b_matrix, l_matrix, m_matrix, grid_size_x, grid_size_z)    # Création de l'état initial    [U, U_gpu] = initial_state(n_x, n_z)    [V, V_gpu] = initial_state(n_x, n_z)    [Sigma_xx, Sigma_xx_gpu] = initial_state(n_x, n_z)    [Sigma_xz, Sigma_xz_gpu] = initial_state(n_x, n_z)    [Sigma_zz, Sigma_zz_gpu] = initial_state(n_x, n_z)    # Importation fonction CUDA    [compute_interpolation_factor, stress_to_velocity, velocity_to_stress, reset_above_surface,     compute_mirror_iteration, assign_value_ghost_point] = function_cuda()    n_z = np.int32(n_z)    # Définition du vecteur stockant les valeurs interpolées et de la matrice des coefficients de l'interpolation    value_interpolated = (np.zeros(n_x)).astype(np.float64)    value_interpolated_gpu = cuda.mem_alloc(value_interpolated.nbytes)    vec = (np.zeros(n_x)).astype(np.float32)    interpolation_factor_gpu = cuda.mem_alloc(interpolation_size * interpolation_size * vec.nbytes)    # Calcul des coefficients d'interpolation    dz = np.float32(dz)    dx = np.float32(dx)    dt = np.float32(dt)    interpolation_size = np.int32(interpolation_size)    compute_interpolation_factor(interpolation_factor_gpu, mirror_point_coordinate_gpu, dx, dz,                                 interpolation_size, n_z, block=(32, 1, 1), grid=(grid_size_x, 1))    # Définition des paramétres d'itération en temps    nt = 0    while nt < n_t:        # Itération en temps        # Calcul des contraintes sur toute la matrice        velocity_to_stress(U_gpu, V_gpu, l_matrix_moved_i_gpu, m_matrix_moved_i_gpu, m_matrix_moved_j_gpu,                           source_position_gpu, Sigma_xx_gpu, Sigma_zz_gpu, Sigma_xz_gpu, dt, dx, dz,                           np.float32(vector_source[nt]), block=(32, 32, 1), grid=(grid_size_x, grid_size_z))        interpolation_on_mirror_point(Sigma_xx_gpu, value_interpolated_gpu, grid_size_x, grid_size_z,                                      ghost_point_matrix_coordinate_z_gpu, interpolation_factor_gpu,                                      mirror_point_coordinate_gpu, n_z, interpolation_size, dx, dz,  reset_above_surface,                                      compute_mirror_iteration, assign_value_ghost_point)        interpolation_on_mirror_point(Sigma_xz_gpu, value_interpolated_gpu, grid_size_x, grid_size_z,                                      ghost_point_matrix_coordinate_z_gpu, interpolation_factor_gpu,                                      mirror_point_coordinate_gpu, n_z, interpolation_size, dx, dz,  reset_above_surface,                                      compute_mirror_iteration, assign_value_ghost_point)        interpolation_on_mirror_point(Sigma_zz_gpu, value_interpolated_gpu, grid_size_x, grid_size_z,                                      ghost_point_matrix_coordinate_z_gpu, interpolation_factor_gpu,                                      mirror_point_coordinate_gpu, n_z, interpolation_size, dx, dz,  reset_above_surface,                                      compute_mirror_iteration, assign_value_ghost_point)        # Calcul des vitesses sur toute la matrice        stress_to_velocity(U_gpu, V_gpu, b_matrix_gpu, b_matrix_moved_ij_gpu, Sigma_xx_gpu, Sigma_zz_gpu, Sigma_xz_gpu,                           dt, dx, dz, block=(32, 32, 1), grid=(grid_size_x, grid_size_z))        interpolation_on_mirror_point(U_gpu, value_interpolated_gpu, grid_size_x, grid_size_z,                                      ghost_point_matrix_coordinate_z_gpu, interpolation_factor_gpu,                                      mirror_point_coordinate_gpu, n_z, interpolation_size, dx, dz,  reset_above_surface,                                      compute_mirror_iteration, assign_value_ghost_point)        interpolation_on_mirror_point(V_gpu, value_interpolated_gpu, grid_size_x, grid_size_z,                                      ghost_point_matrix_coordinate_z_gpu, interpolation_factor_gpu,                                      mirror_point_coordinate_gpu, n_z, interpolation_size, dx, dz,  reset_above_surface,                                      compute_mirror_iteration, assign_value_ghost_point)        nt += 1    # On importe les données des allocations mémoires    cuda.memcpy_dtoh(U, U_gpu)    cuda.memcpy_dtoh(V, V_gpu)    cuda.memcpy_dtoh(Sigma_xx, Sigma_xx_gpu)    cuda.memcpy_dtoh(Sigma_zz, Sigma_zz_gpu)    cuda.memcpy_dtoh(Sigma_xz, Sigma_xz_gpu)    context.pop()    return ([X, Z, U, V, Sigma_xx, Sigma_xz, Sigma_zz])def propagation(b_matrix, l_matrix, m_matrix, dx, dz, dt, source_coordinate, source_vector, data_x, data_z, gpu_used):    # Treating the entry    cuda.init()    dev = cuda.Device(gpu_used)    context = dev.make_context()    [n_x, n_z, X, Z, source_position_gpu, ghost_point_coordinate_gpu, mirror_point_coordinate_gpu] = treating_entry(dx,                                                                                                                    dz,                                                                                                                    source_coordinate,                                                                                                                    b_matrix,                                                                                                                    data_x,                                                                                                                    data_z)    Nt = len(source_vector)    # Création des maillages décalés pour les caractéristiques de la surface    longueur_grille_x = (n_x - 2) // 32    longueur_grille_z = (n_z - 2) // 32    [B_gpu, B_dec_ij_gpu, L_dec_i_gpu, M_dec_i_gpu, M_dec_j_gpu] = treating_soil_matrix(b_matrix, l_matrix, m_matrix,                                                                                        longueur_grille_x,                                                                                        longueur_grille_z)    # Création de l'état initial    [U, U_gpu] = initial_state(n_x, n_z)    [V, V_gpu] = initial_state(n_x, n_z)    [Sigma_xx, Sigma_xx_gpu] = initial_state(n_x, n_z)    [Sigma_xz, Sigma_xz_gpu] = initial_state(n_x, n_z)    [Sigma_zz, Sigma_zz_gpu] = initial_state(n_x, n_z)    # Importation fonction CUDA    [Calcul_coefficient_interpolation, stress_to_velocity, velocity_to_stress, Mise_a_zero, Calcul_iteration_miroir,     Assign_iteration_miroir] = function_cuda()    # Calcul des coefficients d'interpolation    dz_gpu = np.float32(dz)    dx_gpu = np.float32(dx)    dt_gpu = np.float32(dt)    # Définition des paramétres d'itération en temps    nt = 0    while nt < Nt:        # Itération en temps        # Calcul des contraintes sur toute la matrice        velocity_to_stress(U_gpu, V_gpu, L_dec_i_gpu, M_dec_i_gpu, M_dec_j_gpu, source_position_gpu, Sigma_xx_gpu,                           Sigma_zz_gpu, Sigma_xz_gpu, dt_gpu, dx_gpu, dz_gpu, np.float32(source_vector[nt]),                           block=(32, 32, 1), grid=(longueur_grille_x, longueur_grille_z))        # Calcul des vitesses sur toute la matrice        stress_to_velocity(U_gpu, V_gpu, B_gpu, B_dec_ij_gpu, Sigma_xx_gpu, Sigma_zz_gpu, Sigma_xz_gpu, dt_gpu, dx_gpu,                           dz_gpu, block=(32, 32, 1), grid=(longueur_grille_x, longueur_grille_z))        nt += 1    # On importe les données des allocations mémoires    cuda.memcpy_dtoh(U, U_gpu)    cuda.memcpy_dtoh(V, V_gpu)    cuda.memcpy_dtoh(Sigma_xx, Sigma_xx_gpu)    cuda.memcpy_dtoh(Sigma_zz, Sigma_zz_gpu)    cuda.memcpy_dtoh(Sigma_xz, Sigma_xz_gpu)    context.pop()    return [X, Z, U, V, Sigma_xx, Sigma_xz, Sigma_zz]if __name__ == '__main__':    # Définition du domaine d'étude    Vp = 3000  # Vitesse des ondes P    Vs = 1500  # Vitesse des ondes S    rho = 2000  # Densité    Nx = 32 * 5 + 2    Nz = 32 * 5 + 2    B = np.ones((Nz, Nx)) / rho    L = (rho * Vp ** 2 - 2 * rho * Vs ** 2) * np.ones((Nz, Nx))    M = (rho * Vs ** 2) * np.ones((Nz, Nx))    dx = 25    dz = 25    dt = 0.005    # Définition de l'emplacement et de la forme de la source    alpha = 500    t0 = 1    Coor_source = [2 * Nx * dx / 4, 2 * Nz * dz / 4]    Nt = 1000    def Fonction_Source(t, alpĥa, retard):        result = (1 - 2 * alpha * (t - retard) ** 2) * np.exp(-alpha * (t - retard) ** 2)        return (result)    Vecteur_source = []    for i in range(Nt):        Vecteur_source.append(Fonction_Source(dt * i, alpha, t0))    # pp.plot(Vecteur_source)    # pp.show()    # Données expérimentale des points de la surface    Nx_data = 51    dx_data = np.float32((Nx * dx) / (Nx_data - 1))    x_data = np.linspace(0, Nx * dx, Nx_data)    # z_data = Nx * dx / 2 * np.exp(    #     -np.square(x_data - Nx * dx / 2 * np.ones(Nx_data)) / (500) ** 2) + Nx * dx / 2.1 * np.ones(Nx_data)    z_data = 3 * Nx * dx / 4 * np.ones(Nx_data)    pp.plot(x_data, z_data)    # limited to show positive axes    pp.xlim(0, Nx * dx)    pp.ylim(0, Nz * dz)    pp.show()    Number_interpolation = 10    [X, Z, U, V, Sigma_xx, Sigma_xz, Sigma_zz] = propagation_with_mirror(B, L, M, dx, dz, dt, Coor_source, Vecteur_source,                                                                       x_data, z_data, Number_interpolation, 1)    # [X, Z, U, V, Sigma_xx, Sigma_xz, Sigma_zz] = propagation(B, L, M, dx, dz, dt, Coor_source, Vecteur_source, x_data,    #                                                      z_data,1)    view_velocity_stress(X, Z, U, V, Sigma_xx, Sigma_zz, Sigma_xz, trace_type="coolwarm")